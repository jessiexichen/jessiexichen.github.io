<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>GPT-SoVITS微调训练</title>
    <link href="/2024/11/15/GPT-SoVITS%E5%BE%AE%E8%B0%83%E8%AE%AD%E7%BB%83/"/>
    <url>/2024/11/15/GPT-SoVITS%E5%BE%AE%E8%B0%83%E8%AE%AD%E7%BB%83/</url>
    
    <content type="html"><![CDATA[<h1 id="GPT-SoVITS微调训练"><a href="#GPT-SoVITS微调训练" class="headerlink" title="GPT-SoVITS微调训练"></a>GPT-SoVITS微调训练</h1><p><img src="https://s2.loli.net/2025/01/02/xcbgva7yiphk4SJ.png" alt="webUI微调界面"></p><h2 id="1-设置batch-size"><a href="#1-设置batch-size" class="headerlink" title="1. 设置batch_size"></a>1. 设置<code>batch_size</code></h2><p>在进行 GPT-SoVITS 微调时，<code>batch_size</code> 的选择非常重要，以下是一些设置建议：</p><h3 id="什么是-batch-size？"><a href="#什么是-batch-size？" class="headerlink" title="什么是 batch_size？"></a>什么是 <code>batch_size</code>？</h3><p><code>batch_size</code>（批量大小）指的是在一次训练迭代中，模型所处理的训练样本数量。更简单地说，<code>batch_size</code> 就是一次性输入到模型中的数据量。比如，如果 <code>batch_size</code> 设置为 16，那么每次迭代时，模型就会从数据集中选择 16 个样本进行训练。较大的 <code>batch_size</code> 会让每次迭代计算更多数据，但会占用更多的显存。</p><h3 id="设置建议："><a href="#设置建议：" class="headerlink" title="设置建议："></a>设置建议：</h3><ul><li><p><strong>显存限制</strong>：<code>batch_size</code> 不应设置过高，通常建议将其设置为显存的一半以下。如果 <code>batch_size</code> 设置过大，可能会导致显存爆满，甚至无法训练。显存过载时，训练过程会变慢，因为显卡可能会开始使用系统内存。</p></li><li><p><strong>效率与性能</strong>：<code>batch_size</code> 的选择并不是越大越好。虽然较大的 <code>batch_size</code> 可以在每次迭代中处理更多数据，从而提高训练效率，但也会增加显存占用，导致显卡的 3D 占用率增加，使用共享显存，从而减慢训练速度。</p></li><li><p><strong>根据数据集调整</strong>：根据数据集的大小调整 <code>batch_size</code>。例如，在显存为 6GB 的显卡上，推荐将 <code>batch_size</code> 设置为 1。笔者的12GB显存显卡上，将 <code>batch_size</code> 设置为 5。将如果数据集更大或者切片长度更长时，应适当减小 <code>batch_size</code>。</p></li><li><p><strong>实际设置</strong>：在切片长度为 10 秒的情况下，以下是不同显存下的最大 <code>batch_size</code>：</p><ul><li><h3 id="查看显存使用情况"><a href="#查看显存使用情况" class="headerlink" title="查看显存使用情况"></a>查看显存使用情况</h3></li></ul></li></ul><p>在windows 和 linux命令行中查看显存使用情况，可以使用 <code>nvidia-smi</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvidia-smi<br></code></pre></td></tr></table></figure><table><thead><tr><th>显存大小</th><th>最大 <code>batch_size</code></th></tr></thead><tbody><tr><td>6GB</td><td>1</td></tr><tr><td>8GB</td><td>2</td></tr><tr><td>16GB</td><td>8</td></tr></tbody></table><p>  如果切片长度更长或数据集更大，建议适当减少 <code>batch_size</code>。</p><h2 id="2-是否使用-DPO-训练"><a href="#2-是否使用-DPO-训练" class="headerlink" title="2. 是否使用 DPO 训练"></a>2. 是否使用 DPO 训练</h2><p>DPO（<strong>Differentiable Prompt Optimization</strong>）训练方法是 GPT-SoVITS 在0213版本之后添加的一种新方法。通过使提示（prompt）能够进行微分，DPO可以在训练过程中自动优化提示，从而显著提高模型的生成效果。它能够减少“吞字”和“复读”现象，并且使得模型可以处理更多字数的文本。然而，DPO训练也有一些挑战，特别是在显存占用和训练速度方面。</p><h3 id="什么是“微分”？"><a href="#什么是“微分”？" class="headerlink" title="什么是“微分”？"></a>什么是“微分”？</h3><p>在机器学习和神经网络中，微分（differentiation）通常是指计算损失函数（loss function）对模型参数的梯度。通过这个梯度信息，可以指导模型参数如何调整，以最小化损失函数，从而提高模型的性能。</p><h3 id="使提示能够进行微分"><a href="#使提示能够进行微分" class="headerlink" title="使提示能够进行微分"></a>使提示能够进行微分</h3><p>传统上，提示（prompt）是固定的、手动设计的文本，不会在训练过程中进行调整。而在 DPO 方法中，提示被视为可以优化的参数，也就是说，通过训练的过程，我们可以调整这些提示的内容，使得模型的表现更加优秀。这意味着提示本身是“可微的”，也可以像神经网络的权重一样通过梯度下降来进行优化。</p><p>具体来说，使提示可微分的过程可能涉及以下几个步骤：</p><ol><li><p><strong>将提示视为可训练的参数</strong>：<br>在模型训练时，提示不仅是一个固定的文本，而是一个可优化的对象。我们可以用一个变量表示提示内容，并通过梯度下降法来优化这个变量。</p></li><li><p><strong>计算提示的梯度</strong>：<br>通过计算模型生成结果和真实目标之间的损失函数（例如，生成文本与实际文本的差异），然后对提示内容计算梯度。这个梯度表示了如何调整提示的内容，以使模型输出更加接近预期。</p></li><li><p><strong>反向传播优化提示</strong>：<br>通过反向传播，利用损失函数的梯度信息来更新提示内容，使其能够更好地引导模型生成高质量的文本。</p></li></ol><h3 id="举个简单的例子："><a href="#举个简单的例子：" class="headerlink" title="举个简单的例子："></a>举个简单的例子：</h3><p>假设我们正在训练一个生成诗歌的模型，我们给定一个初始提示：”写一首关于秋天的诗”，但希望优化这个提示，以便模型生成的诗歌更加优美。传统的做法是手动修改提示，比如修改为：”写一首描述秋天景色的诗”，但是在 DPO 中，我们可以通过训练自动优化这个提示。</p><ul><li><strong>初始提示</strong>： “写一首关于秋天的诗”。</li><li><strong>模型生成的诗歌</strong>： 秋天的树叶掉落，秋天的风很凉。</li><li><strong>计算损失</strong>：通过计算这个生成文本与目标文本（例如：一首优美的秋天诗）之间的差异，我们可以计算损失。</li><li><strong>DPO优化后的提示</strong>： DPO 通过反向传播调整提示，使其变成：”写一首生动描绘秋天景色和情感的诗”。</li><li><strong>新的模型输出</strong>： 新的提示引导模型生成更符合目标的诗歌。</li></ul><h3 id="DPO训练的优缺点："><a href="#DPO训练的优缺点：" class="headerlink" title="DPO训练的优缺点："></a>DPO训练的优缺点：</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li><strong>效果提升</strong>：通过优化提示，DPO能够显著改善生成文本的质量，减少吞字和复读问题，提高生成文本的连贯性和准确性。</li><li><strong>推理能力增强</strong>：DPO训练能够使模型处理更多的字数，在推理时生成更长的文本。</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li><strong>显存需求增加</strong>：DPO训练需要更多的显存，通常显存占用会是传统训练方法的两倍以上，因此需要至少12GB显存的显卡。</li><li><strong>训练速度变慢</strong>：DPO训练比传统方法慢约4倍，需要更长的训练时间。</li><li><strong>数据集质量要求高</strong>：DPO对数据集的质量要求较高，数据集中的杂音、混响或标注错误会导致模型效果下降，甚至可能产生负面影响。</li></ul><h3 id="是否开启DPO训练："><a href="#是否开启DPO训练：" class="headerlink" title="是否开启DPO训练："></a>是否开启DPO训练：</h3><ul><li><p><strong>开启DPO训练的条件</strong>：</p><ul><li>显卡显存大于12GB。</li><li>训练数据集质量较好（无杂音，标注准确）。</li><li>能够接受较长的训练时间。</li></ul></li><li><p><strong>不推荐开启DPO训练的情况</strong>：</p><ul><li>显卡显存小于12GB。</li><li>数据集质量不理想（例如，音质差或标注不准确）。</li><li>希望快速完成训练任务。</li></ul></li></ul><h3 id="显存与-batch-size-配置表"><a href="#显存与-batch-size-配置表" class="headerlink" title="显存与 batch_size 配置表"></a>显存与 <code>batch_size</code> 配置表</h3><table><thead><tr><th>显存</th><th>未开启 DPO <code>batch_size</code></th><th>开启 DPO <code>batch_size</code></th><th>切片长度</th></tr></thead><tbody><tr><td>6GB</td><td>1</td><td>无法训练</td><td>10s</td></tr><tr><td>8GB</td><td>2</td><td>无法训练</td><td>10s</td></tr><tr><td>12GB</td><td>4</td><td>1</td><td>10s</td></tr><tr><td>16GB</td><td>7</td><td>1</td><td>10s</td></tr><tr><td>22GB</td><td>10</td><td>4</td><td>10s</td></tr><tr><td>24GB</td><td>11</td><td>6</td><td>10s</td></tr><tr><td>32GB</td><td>16</td><td>6</td><td>10s</td></tr><tr><td>40GB</td><td>21</td><td>8</td><td>10s</td></tr><tr><td>80GB</td><td>44</td><td>18</td><td>10s</td></tr></tbody></table><h2 id="3-设置轮数"><a href="#3-设置轮数" class="headerlink" title="3.设置轮数"></a>3.设置轮数</h2><p>在机器学习和神经网络中，<code>轮数（Epoch）</code>是指整个训练数据集通过模型一次的过程。每一轮（epoch）中，模型会使用训练数据集中的所有样本进行一次前向传播和反向传播的过程，更新模型的权重。</p><h3 id="轮数的作用"><a href="#轮数的作用" class="headerlink" title="轮数的作用"></a>轮数的作用</h3><ul><li>训练不够：如果轮数过少，模型可能没有足够的时间去学习数据中的模式，导致欠拟合。</li><li>过度训练：如果轮数过多，模型可能会过度拟合训练数据，导致泛化能力下降。</li></ul><h3 id="选择适当的轮数："><a href="#选择适当的轮数：" class="headerlink" title="选择适当的轮数："></a>选择适当的轮数：</h3><p>通常在训练过程中，通过监控验证集的性能来选择适当的轮数。如果训练损失持续减少，但验证损失开始上升，可能就到了过拟合的临界点，此时应停止。</p><ul><li>当底噪、混响、喷麦、响度不统一、电流声、口水音、口齿不清、音质差等情况那么请不要调高SoVITS模型轮数，否则会有负面效果。</li><li>GPT-SoVITS模型轮数一般情况下不高于20，建议设置10。</li></ul><h2 id="4-开始训练"><a href="#4-开始训练" class="headerlink" title="4.开始训练"></a>4.开始训练</h2>]]></content>
    
    
    
    <tags>
      
      <tag>ai</tag>
      
      <tag>tts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵快速幂test版</title>
    <link href="/2024/11/08/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <url>/2024/11/08/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<p><span class="math display">\[E=mc^2\]</span>矩阵快速幂是一种基于矩阵的快速幂算法。与普通的快速幂算法类似，它利用分治法对矩阵进行快速乘法运算，从而在对矩阵进行幂运算时减少计算量。矩阵快速幂的核心思想是通过反复平方来加速矩阵的幂计算，特别适用于需要计算矩阵高次幂的场景。</p><h2 id="矩阵乘法">矩阵乘法</h2><p>矩阵乘法是矩阵运算中最基本且最重要的运算之一。在进行矩阵乘法时，要求第一个矩阵的列数（column）和第二个矩阵的行数（row）相同。</p><p>假设矩阵 ( A ) 为 ( m p ) 的矩阵，矩阵 ( B ) 为 ( p n )的矩阵，那么它们的乘积矩阵 ( C ) 为 ( m n ) 的矩阵，其中矩阵 ( C )的每个元素 ( C_{ij} ) 是矩阵 ( A ) 的第 ( i ) 行和矩阵 ( B ) 的第 ( j )列的点积。具体公式如下：</p><p>[ C_{ij} = <em>{k=1}^{p} A</em>{ik} B_{kj} ]</p><p>这意味着要计算矩阵 ( C ) 中的元素 ( C_{ij} )，需要枚举矩阵 ( A )的行和矩阵 ( B ) 的列。为了确保矩阵乘法合法，必须满足矩阵 ( A )的列数等于矩阵 ( B ) 的行数。</p><h2 id="矩阵快速幂算法">矩阵快速幂算法</h2><p>矩阵快速幂的思想与普通快速幂相似，即利用分治法将幂次拆分为小的部分进行计算。在矩阵快速幂中，我们对矩阵进行连续平方，从而减少乘法次数，快速得到矩阵的高次幂。</p><p>矩阵快速幂的算法流程可以分为以下几个步骤：</p><ol type="1"><li><p><strong>初始化矩阵</strong>： 创建一个单位矩阵<code>res</code>，这是因为任何矩阵与单位矩阵相乘，都会得到原矩阵。</p></li><li><p><strong>循环迭代</strong>： 对矩阵 ( a )进行快速幂计算，逐次平方矩阵并乘以当前的<code>res</code>，直到幂指数为零。</p></li><li><p><strong>奇偶判断</strong>：每次计算时，判断当前幂指数是奇数还是偶数。如果是奇数，先将当前矩阵乘到<code>res</code>上，然后将矩阵平方；如果是偶数，直接将矩阵平方。</p></li></ol><p>以下是矩阵快速幂的代码实现：</p><p>```cpp // 定义矩阵结构体 struct Matrix { int mat[MAX][MAX]; //矩阵的元素 int m, n; // 矩阵的行数和列数 };</p><p>// 矩阵乘法运算符重载 Matrix operator<em>(const Matrix&amp; a, constMatrix&amp; b) { Matrix c; // 初始化结果矩阵c for (int i = 0; i &lt;a.m; i++) { for (int j = 0; j &lt; b.n; j++) { c.mat[i][j] = 0; for (intk = 0; k &lt; a.n; k++) { c.mat[i][j] = (c.mat[i][j] + a.mat[i][k] </em>b.mat[k][j]) % mod; } } } return c; // 返回乘积矩阵 }</p><p>// 矩阵快速幂运算符重载 Matrix operator^(Matrix a, long long b) {Matrix res, tmp; tmp = a; // tmp初始为a</p><pre><code class="hljs">// 初始化单位矩阵resfor (int i = 0; i &lt; a.m; i++) &#123;    for (int j = 0; j &lt; a.m; j++) &#123;        if (i == j) res.mat[i][j] = 1; // 单位矩阵        else res.mat[i][j] = 0;    &#125;&#125;// 快速幂计算while (b &gt; 0) &#123;    if (b &amp; 1) res = res * tmp; // 如果当前位为1，乘上当前矩阵    tmp = tmp * tmp; // tmp平方    b /= 2; // 右移一位&#125;return res; // 返回矩阵的最终结果</code></pre><p>}</p>]]></content>
    
    
    
    <tags>
      
      <tag>oi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树</title>
    <link href="/2024/10/25/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <url>/2024/10/25/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="最小生成树">最小生成树</h1><h2 id="目录">目录</h2><ul><li><a href="#kruskal算法">Kruskal算法</a></li><li><a href="#prim算法">Prim算法</a></li></ul><h2 id="kruskal算法">Kruskal算法</h2><p>Kruskal算法找到安全边的办法是在所有连接森林中两棵不同树的边里面，找到权重最小的边((u,v))。设 (C) 和 (C_2) 为边 ((u,v)) 所连接的两棵树。由于边 ((u,v))一定是连接 (C) 和其他某棵树的一条轻量级边，推论隐含告诉我们，边 ((u,v))是 (C)的一条安全边。很显然，Kruskal算法属于贪心算法，因为它每次都选择一条权重最小的边加入到森林。</p><p>Kruskal算法的实现与计算连通分量的算法类似。我们使用一个不相交集合数据结构来维护几个互不相交的元素集合。每个集合代表当前森林中的一棵树。操作<code>FIND-SET(u)</code> 用来返回包含元素 (u)的集合的代表元素。我们可以通过测试 <code>FIND-SET(u)</code> 是否等于<code>FIND-SET(v)</code> 来判断节点 (u) 和节点 (v)是否属于同一棵树。Kruskal算法使用 <code>UNION</code>过程来对两棵树进行合并。</p><h2 id="模板代码">模板代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m); <span class="hljs-comment">// n个点，m条边</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;e[i].u, &amp;e[i].v, &amp;e[i].val); <span class="hljs-comment">// 输入点的编号和权重</span><br><br>makeset(n); <span class="hljs-comment">// 1对所有点的双亲进行初始化</span><br>sort(e + <span class="hljs-number">1</span>, e + m + <span class="hljs-number">1</span>, cmp); <span class="hljs-comment">// 对所有边的权重进行排序</span><br><br><span class="hljs-type">int</span> edgenum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化边数量</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>    <span class="hljs-keyword">if</span> (find(e[i].u) != find(e[i].v)) &#123;<br>        <span class="hljs-comment">// 1如果这两个点不在同一个边集内，连接两点</span><br>        Union(e[i].u, e[i].v); <span class="hljs-comment">// 合并两点</span><br>        MST += e[i].val; <span class="hljs-comment">// 总长度加上权重</span><br>        edgenum++; <span class="hljs-comment">// 边数+1</span><br>        <span class="hljs-keyword">if</span> (e[i].val &gt; maxn) maxn = e[i].val; <span class="hljs-comment">// 记录最大边权</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 比较函数，用于按权重从小到大排序</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(edge x, edge y)</span> &#123;<br>    <span class="hljs-keyword">return</span> x.val &lt; y.val;<br>&#125;<br><br><span class="hljs-comment">// 查找函数，返回节点的父节点</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (fa[x] != x)<br>        fa[x] = find(fa[x]); <span class="hljs-comment">// 如果当前父亲节点不是自身，递归向上查找</span><br>    <span class="hljs-keyword">return</span> fa[x]; <span class="hljs-comment">// 返回父节点</span><br>&#125;<br><br><span class="hljs-comment">// 合并函数，将 x 和 y 合并在一起</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-type">int</span> rootx = find(x), rooty = find(y); <span class="hljs-comment">// 查找 x 和 y 的根节点</span><br>    fa[rootx] = rooty; <span class="hljs-comment">// 将 x 的根节点连接到 y 的根节点</span><br>&#125;<br><br><span class="hljs-comment">// 初始化集合，将每个点的父节点设置为自身</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">makeset</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        fa[i] = i;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1id="例题scoi2005-繁忙的都市-httpswww.luogu.com.cnproblemp2330">例题：[SCOI2005繁忙的都市] https://www.luogu.com.cn/problem/P2330</h1><p>城市 C是一个非常繁忙的大都市。由于城市中的道路十分拥挤，市长决定对部分道路进行改造。城市C 的道路布局如下：</p><ul><li>城市中有多个交叉路口，有些交叉路口之间有道路相连。</li><li>每两个交叉路口之间最多只有一条双向道路，连接所有交叉路口形成了一个连通图。</li><li>每条道路都有一个分值，分值越小表示道路越繁忙，且更需要进行改造。</li></ul><h2 id="问题描述">问题描述</h2><p>由于市政府的资金有限，市长希望在尽量减少改造道路数量的情况下优化交通。市长提出了以下要求：</p><ol type="1"><li><strong>改造的道路能够连通所有交叉路口</strong>：即所有交叉路口直接或间接连通。</li><li><strong>在满足连通要求的前提下，改造的道路数量最少</strong>。</li><li><strong>在满足以上两点的情况下，改造道路的分值中最大分值尽量小</strong>。</li></ol><h2 id="任务">任务</h2><p>作为市规划局的一员，你需要作出最佳决策，选择适当的道路进行改造以满足市长的要求。</p><h2 id="输入格式">输入格式</h2><ul><li>第一行包含两个整数 ( n ) 和 ( m)，分别表示城市中的交叉路口数和道路数。</li><li>接下来的 ( m ) 行，每行包含三个整数 ( u )、( v ) 和 ( c)，表示交叉路口 ( u ) 和 ( v ) 之间有一条分值为 ( c ) 的道路。</li></ul><p>约束条件： - ( 1 n ) - ( 1 c )</p><h2 id="输出格式">输出格式</h2><ul><li>输出两个整数 ( s ) 和 ( )，其中 ( s ) 表示被选中的道路数，( )表示选中的道路中分值最大的那条道路的分值。</li></ul><h2 id="样例输入">样例输入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">4 5<br>1 2 3<br>1 4 5<br>2 4 7<br>2 3 6<br>3 4 8<br></code></pre></td></tr></table></figure><h2 id="样例输出">样例输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">3 6<br></code></pre></td></tr></table></figure><h2 id="解题思想">解题思想</h2><p>此问题可以通过 <strong>Kruskal算法</strong>来解决。在构造最小生成树的过程中，我们可以同时记录边的数量和其中最大权值。</p><p>Kruskal算法的步骤如下：</p><ol type="1"><li><strong>对所有边按权值从小到大排序</strong>，优先选择权值较小的边。</li><li>使用 <strong>并查集</strong>判断当前边的两个节点是否属于同一个连通分量。如果不是，则将此边加入最小生成树，并更新边的数量和最大权值。</li><li>当所有交叉路口连通后，输出选中的边数和最大权值。</li></ol><h2 id="代码实现">代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> fa[<span class="hljs-number">1600000</span>]; <span class="hljs-comment">// 记录父节点</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123;<br>    <span class="hljs-type">int</span> u, v, val; <span class="hljs-comment">// u, v 为节点，val 是权值</span><br>&#125; e[<span class="hljs-number">1000000</span>];<br><br><span class="hljs-type">int</span> n, m; <span class="hljs-comment">// n 个点，m 条边</span><br><span class="hljs-type">int</span> MST = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录最小生成树权值</span><br><span class="hljs-type">int</span> maxn = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录最大权值</span><br><br><span class="hljs-comment">// 比较函数，用于按权值从小到大排序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(edge x, edge y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x.val &lt; y.val;<br>&#125;<br><br><span class="hljs-comment">// 查找函数，返回节点的父节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (fa[x] != x)<br>        fa[x] = <span class="hljs-built_in">find</span>(fa[x]); <span class="hljs-comment">// 如果当前父节点不是自身，递归向上查找</span><br>    <span class="hljs-keyword">return</span> fa[x]; <span class="hljs-comment">// 返回父节点</span><br>&#125;<br><br><span class="hljs-comment">// 合并函数，将 x 和 y 合并在一起</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-type">int</span> rootx = <span class="hljs-built_in">find</span>(x), rooty = <span class="hljs-built_in">find</span>(y); <span class="hljs-comment">// 查找 x 和 y 的根节点</span><br>    fa[rootx] = rooty; <span class="hljs-comment">// 将 x 的根节点连接到 y 的根节点</span><br>&#125;<br><br><span class="hljs-comment">// 初始化集合，将每个点的父节点设置为自身</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeset</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        fa[i] = i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m); <span class="hljs-comment">// 输入 n 个点，m 条边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;e[i].u, &amp;e[i].v, &amp;e[i].val); <span class="hljs-comment">// 输入点的编号和权重</span><br><br>    <span class="hljs-built_in">makeset</span>(n); <span class="hljs-comment">// 初始化集合</span><br>    <span class="hljs-built_in">sort</span>(e + <span class="hljs-number">1</span>, e + m + <span class="hljs-number">1</span>, cmp); <span class="hljs-comment">// 对所有边按权重排序</span><br><br>    <span class="hljs-type">int</span> edgenum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化边数量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(e[i].u) != <span class="hljs-built_in">find</span>(e[i].v)) &#123;<br>            <span class="hljs-comment">// 如果这两个点不在同一个集合内，连接两点</span><br>            <span class="hljs-built_in">Union</span>(e[i].u, e[i].v); <span class="hljs-comment">// 合并两点</span><br>            MST += e[i].val; <span class="hljs-comment">// 累加边的权重</span><br>            edgenum++; <span class="hljs-comment">// 边数 +1</span><br>            <span class="hljs-keyword">if</span> (e[i].val &gt; maxn) maxn = e[i].val; <span class="hljs-comment">// 记录最大边权</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, edgenum, maxn); <span class="hljs-comment">// 输出边数量和最大边权值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="prim算法">PRIM算法</h1><p>与 Kruskal 算法类似，Prim 算法也是通用最小生成树算法的一个特例。Prim算法的工作原理与 Dijkstra 的最短路径算法相似。Prim算法所具有的一个性质是集合 A中的边总是构成一棵树。这棵树从一个任意的根节点 ( r )开始，一直扩展到覆盖图 ( V ) 中的所有节点为止。</p><p>算法每一步在连接集合 A 和 A之外的节点的所有边中，选择一条轻量级边加入到 A中。根据相关推论，这条规则所加入的边都是对 A安全的边。因此，当算法终止时，A 中的边形成一棵最小生成树。</p><p>这个策略也属于贪心策略，因为每一步都选择当前可行的最优解。</p><p>为了有效地实现 Prim算法，需要一种快速的方法来选择一条新的边，以便加入到由集合 A中的边所构成的树里。在下面的伪代码中，连通图 ( G )和最小生成树的根节点将作为算法的输入。</p><p>在算法的执行过程中，所有不在树 A中的节点都存放在一个基于关键属性的最小优先队列 ( Q ) 中。对于每个节点 (v )，属性 ( u_k ) 保存的是连接 ( v )和树中节点的所有边中最小边的权重。我们约定，如果不存在这样的边，则 ( u_k= )。属性 ( u_{} ) 给出的是节点 ( v ) 在树中的父节点。</p><p>Prim 算法将 GENERIC-MST 中的集合 A 维持在以下状态： [ A = { (o, u_{}): v V { r } } ]</p><p>当 Prim 算法终止时，最小优先队列 ( Q ) 将为空，而 ( G ) 的最小生成树( A ) 则是： [ A = { (o, u_{}) : v V { r } } ]</p><h2 id="prim-算法实现代码">Prim 算法实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        parent[i] = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 初始化每个节点的父亲</span><br>    dis[start] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 开始节点初始化</span><br>    visit[start] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始节点是否被访问</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">-1</span>, DIST = INT_MAX; <span class="hljs-comment">// 设定初始值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-comment">// 找到当前离树最近的边</span><br>            <span class="hljs-keyword">if</span> (visit[j] == <span class="hljs-number">0</span> &amp;&amp; DIST &gt; dis[j]) &#123;<br>                DIST = dis[j]; <span class="hljs-comment">// 更新最小值</span><br>                u = j; <span class="hljs-comment">// 更新节点编号</span><br>            &#125;<br>        &#125;<br>        MST += DIST; <span class="hljs-comment">// 加上当前边权值</span><br>        visit[u] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 标记已访问</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-comment">// 如果这个点未被访问且当前节点到这个点的距离更短</span><br>            <span class="hljs-keyword">if</span> (visit[j] == <span class="hljs-number">0</span> &amp;&amp; mat[u][j] &lt; dis[j]) &#123;<br>                dis[j] = mat[u][j]; <span class="hljs-comment">// 更新距离值</span><br>                parent[j] = u; <span class="hljs-comment">// 更新父节点</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="例题最优布线问题">例题：最优布线问题</h1><p>学校有台计算机，为了方便数据传输，现要将它们用数据线连接起来。两台计算机被连接是指它们有数据线连接。由于计算机所处的位置不同，因此不同的两台计算机的连接费用往往是不同的。</p><p>当然，如果将任意两台计算机都用数据线连接，费用将是相当庞大的。为了节省费用，我们采用数据的间接传输手段，即一台计算机可以间接地通过若干台计算机（作为中转）来实现与另一台计算机的连接。</p><p>现在由你负责连接这些计算机，任务是使任意两台计算机都连通（不管是直接的或间接的）。以下是关于最优布线问题的输入输出格式整理，使用 Markdown 语言：</p><h2 id="输入">输入</h2><p>第一行为整数 ( n ) ( ( 2 n ) )，表示计算机的数目。此后的 ( n )行，每行 ( n ) 个整数。第 ( x+1 ) 行 ( y ) 列的整数表示直接连接第 ( x )台计算机和第 ( y ) 台计算机的费用。</p><h2 id="输出">输出</h2><p>一个整数，表示最小的连接费用。</p><h2 id="样例输入-1">样例输入</h2><p>3 0 1 2 1 0 1 2 1 0</p><h2 id="样例输出-1">样例输出</h2><p>2</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> mat[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>], MST, parent[<span class="hljs-number">1005</span>], dis[<span class="hljs-number">1005</span>];<br><span class="hljs-comment">/* mat -&gt; 邻接矩阵，MST -&gt; 最小生成树权值和</span><br><span class="hljs-comment">   parent[i] 记录 i 节点的父亲</span><br><span class="hljs-comment">   dis[i] 记录生成树中点 i 的最近距离 */</span><br><span class="hljs-type">int</span> visit[<span class="hljs-number">1005</span>], n; <span class="hljs-comment">// visit 记录 i 点是否被访问，n 为节点个数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> oo = INT_MAX;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        parent[i] = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 初始化每个节点的父亲</span><br>        dis[i] = oo; <span class="hljs-comment">// 初始化 i 点到生成树的距离</span><br>        visit[i] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化 i 节点是否被访问</span><br>    &#125;<br>    dis[start] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 开始的节点初始化</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">-1</span>, DIST = oo; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-comment">// 找到当前离树最近的边</span><br>            <span class="hljs-keyword">if</span> (visit[j] == <span class="hljs-number">0</span> &amp;&amp; DIST &gt; dis[j]) &#123;<br>                DIST = dis[j]; <span class="hljs-comment">// 更新最小值</span><br>                u = j; <span class="hljs-comment">// 更新节点编号</span><br>            &#125;<br>        &#125;<br>        MST += DIST; <span class="hljs-comment">// 加上当前边权值</span><br>        visit[u] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 标记已访问</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-comment">// 如果这个点未被访问且当前节点到这个点的距离更短</span><br>            <span class="hljs-keyword">if</span> (visit[j] == <span class="hljs-number">0</span> &amp;&amp; mat[u][j] &lt; dis[j]) &#123;<br>                dis[j] = mat[u][j]; <span class="hljs-comment">// 更新距离值</span><br>                parent[j] = u; <span class="hljs-comment">// 更新父节点</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;mat[i][j]);<br>    <span class="hljs-built_in">prim</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, MST);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>oi</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
